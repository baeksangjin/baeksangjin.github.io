<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BAEK Labs | Kinetic Organic Zone</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #ffffff; overflow: hidden; cursor: crosshair; transition: background-color 0.8s ease; touch-action: none; }
        canvas { display: block; }
        #ui-layer { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 100; }
        .mode-btn {
            background: transparent; border: 1px solid #000000; padding: 14px 32px; border-radius: 0;
            font-family: 'Montserrat', sans-serif; font-size: 10px; font-weight: 400; letter-spacing: 5px;
            cursor: pointer; color: #000000; outline: none; text-transform: uppercase; 
            display: inline-block; text-align: center; min-width: 140px;
            -webkit-tap-highlight-color: transparent;
        }
        body.dark-mode { background-color: #000000; }
        body.dark-mode .mode-btn { border-color: #ffffff; color: #ffffff; }
    </style>
</head>
<body id="main-body">

<div id="ui-layer">
    <button class="mode-btn" id="kinetic-btn" onclick="handleModeSwitch()">VOID</button>
</div>

<script>
let particles = [];
let numParticles;
let isDark = false;
let bgColor = 255;
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let interval = null;

let lastInputTime = 0;
let noiseX = 0, noiseY = 1000, noiseSpeed = 2000; 
let currentCursor; // Tracks the actual effective cursor position

function setup() {
    createCanvas(windowWidth, windowHeight);
    numParticles = (windowWidth < 768) ? 4000 : 12000;
    currentCursor = createVector(width / 2, height / 2);
    
    for (let i = 0; i < numParticles; i++) {
        particles.push(new Particle());
    }
}

function draw() {
    background(bgColor);
    
    // Check for user activity
    if (mouseX !== pmouseX || mouseY !== pmouseY || mouseIsPressed) {
        lastInputTime = millis();
    }

    let targetX, targetY;
    
    // Idle threshold increased to 2 seconds (2000ms)
    if (millis() - lastInputTime > 2000) {
        let speedVariation = noise(noiseSpeed) * 0.015;
        noiseX += speedVariation;
        noiseY += speedVariation;
        noiseSpeed += 0.01;
        
        targetX = noise(noiseX) * width;
        targetY = noise(noiseY) * height;
    } else {
        targetX = mouseX;
        targetY = mouseY;
    }

    // Seamless Transition: Always lerp currentCursor towards target (Auto or Manual)
    // This ensures that when the user moves the mouse, it starts following from the last idle position.
    currentCursor.x = lerp(currentCursor.x, targetX, 0.15);
    currentCursor.y = lerp(currentCursor.y, targetY, 0.15);

    for (let p of particles) {
        p.update();
        p.bounce();
        p.interact(currentCursor.x, currentCursor.y);
        p.show();
    }
}

class Particle {
    constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = p5.Vector.random2D().mult(random(5, 60));
        this.baseSpeed = random() > 0.9 ? random(1.2, 2.1) : random(0.15, 0.9);
        this.origVel = p5.Vector.random2D().mult(this.baseSpeed);
        
        let offsetScale = (windowWidth < 768) ? 100 : 200;
        let angle = random(TWO_PI);
        let r = random(offsetScale);
        this.offset = createVector(r * cos(angle), r * sin(angle));
        
        let rChance = random(1);
        if (rChance > 0.993) this.r = random(10.8, 16.2);
        else if (rChance > 0.88) this.r = random(5, 9);
        else this.r = random(1.6, 3.7);
        this.isPressed = false;
    }

    update() {
        this.pos.add(this.vel);
        if (!mouseIsPressed && this.vel.mag() > this.baseSpeed) {
            this.vel.mult(0.96);
        }
    }

    interact(tx, ty) {
        let targetVec = createVector(tx, ty);
        let fleeRadius = (windowWidth < 768) ? 56 : 112;

        if (mouseIsPressed) {
            let target = p5.Vector.add(targetVec, this.offset);
            let arrive = p5.Vector.sub(target, this.pos);
            let dist = arrive.mag();
            if (dist < 15) {
                this.vel.mult(0.85);
                this.vel.add(p5.Vector.random2D().mult(0.15));
            } else {
                let speed = map(dist, 0, width, 40, 180);
                arrive.setMag(speed);
                this.vel = p5.Vector.lerp(this.vel, arrive, 0.15);
            }
            this.isPressed = true;
        } else {
            if (this.isPressed) {
                this.vel = p5.Vector.random2D().mult(random(40, 90));
                this.isPressed = false;
            }
            let d = p5.Vector.dist(this.pos, targetVec);
            if (d < fleeRadius) {
                let flee = p5.Vector.sub(this.pos, targetVec);
                flee.setMag(2.5);
                this.vel.add(flee);
            } else {
                this.vel.x = lerp(this.vel.x, this.origVel.x, 0.04);
                this.vel.y = lerp(this.vel.y, this.origVel.y, 0.04);
            }
        }
    }

    bounce() {
        if (this.pos.x <= 0 || this.pos.x >= width) { this.vel.x *= -1; this.origVel.x *= -1; this.pos.x = constrain(this.pos.x, 0, width); }
        if (this.pos.y <= 0 || this.pos.y >= height) { this.vel.y *= -1; this.origVel.y *= -1; this.pos.y = constrain(this.pos.y, 0, height); }
    }

    show() {
        noStroke();
        fill(isDark ? 255 : 0);
        ellipse(this.pos.x, this.pos.y, this.r);
    }
}

function handleModeSwitch() {
    isDark = !isDark;
    const body = document.getElementById('main-body');
    const targetText = isDark ? "MANIFEST" : "VOID";
    decodeText(targetText);
    if (isDark) { body.classList.add('dark-mode'); bgColor = 0; }
    else { body.classList.remove('dark-mode'); bgColor = 255; }
}

function decodeText(targetText) {
    const btn = document.getElementById("kinetic-btn");
    let iteration = 0;
    let stopTimings = targetText.split("").map(() => Math.random() * 15 + 5);
    clearInterval(interval);
    interval = setInterval(() => {
        btn.innerText = targetText.split("").map((l, i) => iteration > stopTimings[i] ? targetText[i] : letters[Math.floor(Math.random() * 26)]).join("");
        if(iteration >= 20) { clearInterval(interval); btn.innerText = targetText; }
        iteration += 1;
    }, 40);
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
