<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BAEK Labs | Kinetic Organic Zone</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;300;400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #ffffff; overflow: hidden; cursor: crosshair; transition: background-color 0.8s ease; touch-action: none; }
        canvas { display: block; }
        body.dark-mode { background-color: #000000; }
    </style>
</head>
<body id="main-body">

<script>
let particles = [];
let numParticles;
let isDark = false;
let bgColor = 255;

let lastInputTime = 0;
let noiseX = 0, noiseY = 1000, noiseSpeed = 2000; 
let currentCursor; 

let audioCtx;
let lastTickSecond = -1;

function setup() {
    createCanvas(windowWidth, windowHeight);
    numParticles = (windowWidth < 768) ? 6000 : 11000;
    currentCursor = createVector(width / 2, height / 2);
    
    for (let i = 0; i < numParticles; i++) {
        particles.push(new Particle());
    }
}

function mousePressed() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    isDark = !isDark;
    const body = document.getElementById('main-body');
    if (isDark) { 
        body.classList.add('dark-mode'); 
        bgColor = 0; 
    } else { 
        body.classList.remove('dark-mode'); 
        bgColor = 255; 
    }
}

function playStaccatoTick() {
    if (!audioCtx || audioCtx.state !== 'running') return;
    
    let osc = audioCtx.createOscillator();
    let gain = audioCtx.createGain();
    let filter = audioCtx.createBiquadFilter();
    
    let baseFreq, decayTime, volume;

    if (!isDark) { 
        osc.type = 'triangle';
        baseFreq = 5000;   
        decayTime = 0.008; 
        volume = 0.05;     
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(4000, audioCtx.currentTime);
    } else {
        osc.type = 'sine';     
        baseFreq = 1200; 
        decayTime = 0.015; 
        volume = 0.1;
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1200, audioCtx.currentTime);
    }
    
    osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime); 
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.001);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + decayTime);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.start();
    osc.stop(audioCtx.currentTime + decayTime + 0.02);
}

function draw() {
    background(bgColor);
    
    let s = second();
    if (s !== lastTickSecond) {
        playStaccatoTick();
        lastTickSecond = s;
    }

    if (mouseX !== pmouseX || mouseY !== pmouseY || mouseIsPressed) {
        lastInputTime = millis();
    }

    let targetX, targetY;
    if (millis() - lastInputTime > 2000) {
        let speedVariation = noise(noiseSpeed) * 0.015;
        noiseX += speedVariation;
        noiseY += speedVariation;
        noiseSpeed += 0.01;
        targetX = noise(noiseX) * width;
        targetY = noise(noiseY) * height;
    } else {
        targetX = mouseX;
        targetY = mouseY;
    }

    currentCursor.x = lerp(currentCursor.x, targetX, 0.15);
    currentCursor.y = lerp(currentCursor.y, targetY, 0.15);

    for (let p of particles) {
        p.update();
        p.bounce();
        p.interact(currentCursor.x, currentCursor.y);
        p.show();
    }
}

class Particle {
    constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = p5.Vector.random2D().mult(random(5, 60));
        this.baseSpeed = random() > 0.9 ? random(1.2, 2.1) : random(0.15, 0.9);
        this.origVel = p5.Vector.random2D().mult(this.baseSpeed);
        
        let offsetScale = (windowWidth < 768) ? 100 : 200;
        let angle = random(TWO_PI);
        let r = random(offsetScale);
        this.offset = createVector(r * cos(angle), r * sin(angle));
        
        let rChance = random(1);
        if (rChance > 0.993) this.r = random(10.8, 16.2);
        else if (rChance > 0.88) this.r = random(5, 9);
        else this.r = random(1.6, 3.7);
        this.isPressed = false;
    }

    update() {
        this.pos.add(this.vel);
        if (!mouseIsPressed && this.vel.mag() > this.baseSpeed) {
            this.vel.mult(0.96);
        }
    }

    interact(tx, ty) {
        let targetVec = createVector(tx, ty);
        let fleeRadius = (windowWidth < 768) ? 70 : 112;

        if (mouseIsPressed) {
            let target = p5.Vector.add(targetVec, this.offset);
            let arrive = p5.Vector.sub(target, this.pos);
            let dist = arrive.mag();
            if (dist < 15) {
                this.vel.mult(0.85);
                this.vel.add(p5.Vector.random2D().mult(0.15));
            } else {
                let speed = map(dist, 0, width, 40, 180);
                arrive.setMag(speed);
                this.vel = p5.Vector.lerp(this.vel, arrive, 0.15);
            }
            this.isPressed = true;
        } else {
            if (this.isPressed) {
                this.vel = p5.Vector.random2D().mult(random(40, 90));
                this.isPressed = false;
            }
            let d = p5.Vector.dist(this.pos, targetVec);
            if (d < fleeRadius) {
                let flee = p5.Vector.sub(this.pos, targetVec);
                flee.setMag(2.5);
                this.vel.add(flee);
            } else {
                this.vel.x = lerp(this.vel.x, this.origVel.x, 0.04);
                this.vel.y = lerp(this.vel.y, this.origVel.y, 0.04);
            }
        }
    }

    bounce() {
        if (this.pos.x <= 0 || this.pos.x >= width) { this.vel.x *= -1; this.origVel.x *= -1; this.pos.x = constrain(this.pos.x, 0, width); }
        if (this.pos.y <= 0 || this.pos.y >= height) { this.vel.y *= -1; this.origVel.y *= -1; this.pos.y = constrain(this.pos.y, 0, height); }
    }

    show() {
        noStroke();
        fill(isDark ? 255 : 0);
        ellipse(this.pos.x, this.pos.y, this.r);
    }
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
